
% Task R3.11
H = [1 0 1 1 0 0 0;
     0 1 0 1 1 0 0;
     0 0 1 0 1 1 0;
     0 0 0 1 0 1 1;
     1 0 0 0 1 0 1;
     1 1 0 0 0 1 0;
     0 1 1 0 0 0 1;];

rankH = gfrank(H, 2); % = 4
% we note that this can be done just by observing that
% this H matrix corresponds to a cyclic code which starts with
% 1 0 1 1 => h(X) = 1 + X^2 + X^3

% Then, the parity-check matrix of cyclic code can be obtained
% by simply dropping the last 3 rows:

H_cyclic = [
     1 0 1 1 0 0 0;
     0 1 0 1 1 0 0;
     0 0 1 0 1 1 0;
     0 0 0 1 0 1 1;];

% so n = 7, n - k = 4, k = 3

% we can put this into systematic form by elementary row operations
% without column permutations (p. 107)

% 1 <- 1 + 3 + 4
% 2 <- 2 + 4
% 3 is fine
% 4 is fine
H_systematic = [
     1 0 0 0  1 0 1;
     0 1 0 0  1 1 1;
     0 0 1 0  1 1 0;
     0 0 0 1  0 1 1;];

% we can check that this is indeed the true systematic matrix by
% comparing it with generator matrix returned by cyclgen, with
% identity matrix being on the other side, so dropped
[h1, g1, k] = cyclgen(7, '1 + X^2 + X^3');
isequal(g1(:,1:3), H_systematic(:, 5:end)); % true




%%%%
% Problem 3.1
G = [
    1 1 1 0 1 0 0 0;
    1 0 0 1 1 1 0 0;
    1 1 0 0 0 1 1 0;
    0 1 1 0 0 0 1 1];

U = de2bi(0:15);

% rows:
% 2 <- 1 + 2
% 4 <- 4 + 3
% columns: swap 4 and 6
G_systematic = [
    1 1 1 0 1 0 0 0;
    0 1 1 1 0 1 0 0;
    1 1 0 1 0 0 1 0;
    1 0 1 1 0 0 0 1];

% codewords list
C = mod(U * G, 2)
C_systematic = mod(U * G_systematic, 2)

% The systematic linear block code generated by G_systematic
% is called a 'combinatorially equivalent code of C'. The two codes
% are possibly different in order of bits in a code words, but if
% we restore the order, the codewords themselves will be equivalent.
% The correspondance between information words and code words is
% also changed, but the codewords themselves are equivalent.
% We can check this with the code below, where we've restored the
% order of bits (inversed the swap of 4 and 6 columns done above) and
% sorted the resulting sequence:
isequal(sort(bi2de(C)), sort(bi2de(C_systematic(:,[1 2 3 6 5 4 7 8])))); % => true

% obtain the systematic version of parity-check matrix H = [I | P^T]
H_systematic = [
    1 0 0 0 1 0 1 1;
    0 1 0 0 1 1 1 0;
    0 0 1 0 1 1 0 1;
    0 0 0 1 0 1 1 1];

% check that this is indeed a systematic parity-check matrix for the code
isequal(H_systematic, gen2par(G_systematic)); % => true

mod(G_systematic * H_systematic.', 2); % => zero-matrix

% non-systematic parity-check matrix is obtained by inverse permutation
% of a systematic parity-check matrix
H = H_systematic(:, [1 2 3 6 5 4 7 8]);

mod(G * H.', 2); % => zero-matrix
mod(C * H.', 2); % => zero-matrix
mod(C_systematic * H_systematic.', 2); % => zero-matrix

% minimum distance of the code is the weight of the 'lightest' non-zero word
distance = min(sum(C_systematic(2:end,:), 2)); % => 4


% Problem 3.2
r = [0 1 1 1 0 1 1 0];
s = mod(r * H_systematic.', 2)

K = de2bi(0:255);
M = [];
for errNum = 1:256
    err = K(errNum, :);
    s_err = mod(err * H_systematic.', 2);
    if (isequal(s_err, s))
        M = [M; err];
    end
end

M
% most probable error pattern - one error in second-to-last bit
% decoded codeword = r with second-to-last bit inverted
c_est = [0 1 1 1 0 1 0 0];
s_est = mod(c_est * H_systematic.', 2); % all zero

p = 0.01;

% Probabilities of errors with a syndrome given
% sum(M, 2); will give you the weights of the error patterns,
% as it can be seen, there are only following weights:
errorWeights = [1 3 5 7];
format short e  % so that Matlab displays different powers
errorProbs = p.^ errorWeights .* (1 - p) .^ (8 - errorWeights)

% probability of an undetectable error is defined by weight distribution
codeWeights = sum(C_systematic, 2);
codeWeights = codeWeights(2:end);
undetectableErrorProb = sum(p .^ codeWeights .* (1 - p) .^ codeWeights)
format short


 